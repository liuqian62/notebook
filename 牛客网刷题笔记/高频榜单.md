# 面试高频榜单
按考察次数排序

## 目录



<div align="center">

   | [TOP1-50](#TOP1-50) | [TOP51-100](#TOP51-100) | [TOP101-150](#TOP101-150) |
   | :---: | :---: |  :---: | 
   |[1](#1)|[51](#51)| [101](#101)| 
   |[2](#2)|[52](#52)| [102](#102)| 
   |[3](#3)|[53](#53)| [103](#103)| 
   |[4](#4)|[54](#54)| [104](#104)| 
   |[5](#5)|[55](#55)| [105](#105)| 
   |[6](#6)|[56](#56)| [106](#106)| 
   |[7](#7)|[57](#57)| [107](#107)| 
   |[8](#8)|[58](#58)| [108](#108)| 
   |[9](#9)|[59](#59)| [109](#109)| 
   |[10](#10)|[60](#60)| [110](#110)| 
   |[11](#11)|[61](#61)| [111](#111)| 
   |[12](#12)|[62](#62)| [112](#112)| 
   |[13](#13)|[63](#63)| [113](#113)| 
   |[14](#14)|[64](#64)| [114](#114)| 
   |[15](#15)|[65](#65)| [115](#115)| 
   |[16](#16)|[66](#66)| [116](#116)| 
   |[17](#17)|[67](#67)| [117](#117)| 
   |[18](#18)|[68](#68)| [118](#118)| 
   |[19](#19)|[69](#69)| [119](#119)| 
   |[20](#20)|[70](#70)| [120](#120)| 
   |[21](#21)|[71](#71)| [121](#121)| 
   |[22](#22)|[72](#72)| [122](#122)| 
   |[23](#23)|[73](#73)| [123](#123)| 
   |[24](#24)|[74](#74)| [124](#124)| 
   |[25](#25)|[75](#75)| [125](#125)| 
   |[26](#26)|[76](#76)| [126](#126)| 
   |[27](#27)|[77](#77)| [127](#127)| 
   |[28](#28)|[78](#78)| [128](#128)| 
   |[29](#29)|[79](#79)| [129](#129)| 
   |[30](#30)|[80](#80)| [130](#130)| 
   |[31](#31)|[81](#81)| [131](#131)| 
   |[32](#32)|[82](#82)| [132](#132)| 
   |[33](#33)|[83](#83)| [133](#133)| 
   |[34](#34)|[84](#84)| [134](#134)| 
   |[35](#35)|[85](#85)| [135](#135)| 
   |[36](#36)|[86](#86)| [136](#136)| 
   |[37](#37)|[87](#87)| [137](#137)| 
   |[38](#38)|[88](#88)| [138](#138)| 
   |[39](#39)|[89](#89)| [139](#139)| 
   |[40](#40)|[90](#90)| [140](#140)| 
   |[41](#41)|[91](#91)| [141](#141)| 
   |[42](#42)|[92](#92)| [142](#142)| 
   |[43](#43)|[93](#93)| [143](#143)| 
   |[44](#44)|[94](#94)| [144](#144)| 
   |[45](#45)|[95](#95)| [145](#145)| 
   |[46](#46)|[96](#96)| [146](#146)| 
   |[47](#47)|[97](#97)| [147](#147)| 
   |[48](#48)|[98](#98)| [148](#148)| 
   |[49](#49)|[99](#99)| [149](#149)| 
   |[50](#50)|[100](#100)| [150](#150)| 


 

</div>




## TOP1-50


### 1
*  反转链表

考察次数 196

描述
```

```
<!-- ![img]() -->
```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        ListNode* pre = NULL;
        ListNode* next= NULL;
        while(pHead){
            next=pHead->next;
            pHead->next = pre;
            pre = pHead;
            pHead=next;
            
        }
        return pre;

    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 2
* 排序

考察次数 141

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 将给定数组排序
     * @param arr int整型vector 待排序的数组
     * @return int整型vector
     */
    
    //交换
    void swap(int& p1, int& p2){
        int tmp = p1;
        p1 = p2;
        p2 = tmp;
    }
    
    //快速排序
    void QuickSort(vector<int>& arr,int left,int right){
        if(left>right) return;
        int mid=partition(arr, left,right);
        QuickSort(arr, left, mid-1);
        QuickSort(arr, mid+1, right);
        
    }
    int partition(vector<int>& arr,int left,int right){
        int mark = arr[right];//最后一个值当标杆
        int counter = left;//记录小于标杆值的个数
        for(int i=left;i<right;i++){
            if(arr[i]<mark){
                swap(arr[i],arr[counter++]);
            }
        }
        swap(arr[counter],arr[right]);//标杆移动到中间位置，返回下标
        return counter;
    }
    //冒泡排序
    void BuubleSort(vector<int>& arr){
        for(int i=0;i<arr.size();i++){
            for(int j=0;j<arr.size()-i-1;j++){
                if(arr[j]>arr[j+1]){
                    swap(arr[j],arr[j+1]);
                }
            }
        }
    }
    
    //插入排序
    void InsertSort(vector<int>& arr){
        for(int i=0;i<arr.size()-1;i++){
            int end=i;
            int key = arr[end+1];
            while(end>=0){
                if(arr[end]>key){
                    arr[end+1]=arr[end];
                    end--;
                }else{
                    break;
                }
            }
            arr[end+1]=key;
        }
    }
    
    //希尔排序
    void ShellSort(vector<int>& arr){
        int len = arr.size();
        int gap =len;
        while(gap>1){
            gap=gap/2;
            for(int i=0;i<len-gap;i++){
                int end = i;
                int key = arr[end+gap];
                while(end>=0){
                    if(arr[end]>key){
                        arr[end+gap]=arr[end];
                        end-=gap;
                    }else{
                        break;
                    }
                }
                arr[end+gap]=key;
            }
        }
    }
    
    //归并排序
    void MergeSort(vector<int>& arr,int left,int right){
        if(left>=right) return;
        int mid=left+(right-left)/2;
        MergeSort(arr, left, mid);
        MergeSort(arr, mid+1, right);
        merge(arr, left, mid,right);
    }
    void merge(vector<int>& arr,int left,int mid, int right){
        vector<int> tmp(right-left+1);
        int i=left,j=mid+1,k=0;
        while(i<=mid&&j<=right){
            tmp[k++]=arr[i]<arr[j]?arr[i++]:arr[j++];
        }
        while(i<=mid) tmp[k++]=arr[i++];
        while(j<=right) tmp[k++]=arr[j++];
        i=left;
        k=0;
        while(i<=right){
            arr[i++]=tmp[k++];
        }
    }
    
    //选择排序
    void SelectionSort(vector<int>& arr){
        int minIndex = 0;
        for(int i=0;i<arr.size();i++){
            minIndex=i;
            for(int j=i+1;j<arr.size();j++){
                if(arr[j]<arr[minIndex]) minIndex=j;
            }
            swap(arr[i],arr[minIndex]);
        }
    }
    
    //堆排序
    void HeapSort(vector<int>& arr)
{
        int arrLen=arr.size();
    //建堆
    for (int i = (arrLen - 1 - 1) / 2; i >= 0; i--)
    {
        AdjustDwon(arr, arrLen, i);
    }
 
    int end = arrLen - 1;
    while (end > 0)
    {
        swap(arr[0], arr[end]);
        AdjustDwon(arr, end, 0);
        end--;
    }
}
    void AdjustDwon(vector<int>& arr, int arrLen, int root)
{
    int parent = root;
    int child = parent * 2 + 1;//默认是左孩子
 
    while (child < arrLen)
    {
        if (child + 1 < arrLen && arr[child + 1] > arr[child])
        {
            child += 1;
        }
 
        if (arr[child] > arr[parent])
        {
            swap(arr[child], arr[parent]);
            parent = child;
            child = parent * 2 + 1;
        }
        else
        {
            break;
        }
    }
}
    
    vector<int> MySort(vector<int>& arr) {
        // write code here
//         QuickSort(arr, 0, arr.size()-1);
//         BuubleSort(arr);
//         InsertSort(arr);
//         ShellSort(arr);
//         MergeSort(arr,0, arr.size()-1);
//         SelectionSort(arr);
        HeapSort(arr);
        
        return arr;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 3
* 	设计LRU缓存结构

考察次数 134

描述
```

```
<!-- ![img]() -->
```cpp
//双向链表
struct Node{
    int key;
    int val;
    Node* pre;
    Node* next;
    Node(int k,int v):key(k),val(v),pre(NULL),next(NULL){};
};
class Solution {
public:
    int _capacity; 
    //双向链表头尾
    Node* head = NULL;
    Node* tail = NULL;
    //哈希表记录key值
    unordered_map<int, Node*> mp;

    
    Solution(int capacity){
         // write code here
        _capacity = capacity;
        head = new Node(0,0);
        tail = new Node(0,0);
        head->next = tail;
        tail->pre =head;
    }
    
    int get(int key) {
         // write code here
        int res = -1;
        if(mp.find(key)!=mp.end()){
            res = mp[key]->val;
            moveToHead(mp[key]);
        }
        return res;
    }
    
    void set(int key, int value){
         // write code here
        if(mp.find(key)==mp.end()){
            Node* node = new Node(key,value);
            mp[key] = node;
            if(_capacity<=0) removeLast();
            else _capacity--;
            insertFirst(node);
        }else{
            mp[key]->val=value;
            moveToHead(mp[key]);
        }
    }
    //移动到表头
    void moveToHead(Node* node){
        if(node->pre==head) return;//已经在表头
        //将节点断开取出
        node->pre->next=node->next;
        node->next->pre=node->pre;
        //插入到表头
        insertFirst(node);
    }
    //插入到表头
    void insertFirst(Node* node){
        node->pre=head;
        node->next=head->next;
        head->next->pre=node;
        head->next=node;
    }
    //删除表尾，最近最少使用
    void removeLast(){
        mp.erase(tail->pre->key);//哈希表中删掉
        //删掉节点
        tail->pre->pre->next=tail;
        tail->pre=tail->pre->pre;
    }

};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* solution = new Solution(capacity);
 * int output = solution->get(key);
 * solution->set(key,value);
 */
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 4
* 实现二叉树先序，中序和后序遍历

考察次数 97

描述
```

```
<!-- ![img]() -->
```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param root TreeNode类 the root of binary tree
     * @return int整型vector<vector<>>
     */
    vector<vector<int> > threeOrders(TreeNode* root) {
        // write code here
        vector<int> pre,mid,post;
        pre_order(root, pre);
        mid_order(root, mid);
        post_order(root, post);
        vector<vector<int>> res={pre,mid,post};
        return res;
    }
    void pre_order(TreeNode* root,vector<int>& pre){
        if(!root) return;
        pre.push_back(root->val);
        pre_order(root->left, pre);
        pre_order(root->right, pre);
    }
    void mid_order(TreeNode* root,vector<int>& mid){
        if(!root) return;        
        mid_order(root->left, mid);
        mid.push_back(root->val);
        mid_order(root->right, mid);
    }
    void post_order(TreeNode* root,vector<int>& post){
        if(!root) return;        
        post_order(root->left, post);
        post_order(root->right, post);
        post.push_back(root->val);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 5
* 最小的k个数

考察次数 82

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> res;
        //排除特殊情况 fast-template
        if(k == 0 || input.size() == 0)
            return res;
        priority_queue<int> q;
        //构建一个k个大小的堆
        for(int i = 0; i < k; i++)
            q.push(input[i]);
        for(int i = k; i < input.size(); i++){
             //较小元素入堆
            if(q.top() > input[i]){
                q.pop();
                q.push(input[i]);
            }
        }
        //堆中元素取出入vector
        for(int i = 0; i < k; i++){
            res.push_back(q.top());
            q.pop();
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 6
* 求二叉树的层序遍历

考察次数 62

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL)
            //如果是空，则直接返回空vector fast-template
            return res;
        //队列存储，进行层次遍历
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* cur;
        while(!q.empty()){
            //记录二叉树的某一行
            vector<int> row;
            int n = q.size();
            //因先进入的是根节点，故每层结点多少，队列大小就是多少
            for(int i = 0; i < n; i++){
                cur = q.front();
                q.pop();
                row.push_back(cur->val);
                //若是左右孩子存在，则存入左右孩子作为下一个层次
                if(cur->left)
                    q.push(cur->left);
                if(cur->right)
                    q.push(cur->right);
            }
            //每一层加入输出
            res.push_back(row);
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 7
* 寻找第K大

考察次数 62

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int findKth(vector<int> a, int n, int K) {
        return quickfind(a, 0, n-1, K);
    }
      
    int quickfind(vector<int>& a, int left, int right, int k) {
        int i = left;
        int j = right;
        int mark = a[left];
          
        while (i < j) {
            while (i < j && a[j] >= mark)
                --j;
            if (i < j)
                a[i++] = a[j];
              
            while (i < j && a[i] <= mark)
                ++i;
            if (i < j)
                a[j--] = a[i];
        }
        a[i] = mark;
          
        //哨兵右侧比他大的数字个数
        int big_num = right - i;
         
        //如果哨兵刚好是第K大的数
        if (k - big_num - 1 == 0)
            return mark;
        else if (k - big_num - 1 > 0) {
            //如果右侧数字个数不够K个，则从左侧找第k-big_num-1大的数
            return quickfind(a, left, i - 1, k - big_num - 1);
        } else {
            //如果右侧数字个数比K多，则在右侧找第K大的数
            return quickfind(a, i + 1, right, k);
        }
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 8
* 两数之和

考察次数 60

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    /**
     * 
     * @param numbers int整型vector 
     * @param target int整型 
     * @return int整型vector
     */
    vector<int> twoSum(vector<int>& numbers, int target) {
        // write code here
        unordered_map<int, int> m;
        for(int i = 0; i<numbers.size();i++){
            if(m.find(target-numbers[i])!=m.end()){
                return {m[target-numbers[i]],i+1};
            }
            m[numbers[i]]=i+1;
        }
        return {-1,-1};
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 9
* 合并两个排序的链表

考察次数 57

描述
```

```
<!-- ![img]() -->
```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        // list1 list2为空的情况
        if(pHead1 == NULL || pHead2 == NULL){
            return pHead1 != NULL ? pHead1 : pHead2;
        }
        // 两个链表元素依次对比
        if(pHead1->val <= pHead2->val){
            // 递归计算 list1.next, list2
            pHead1->next = Merge(pHead1->next, pHead2);
            return pHead1;
        }else{
            // 递归计算 list1, list2.next
            pHead2->next = Merge(pHead1, pHead2->next);
            return pHead2;
        } 
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 10
* 用两个栈实现队列

考察次数 57

描述
```

```
<!-- ![img]() -->
```cpp
class Solution
{
public:
    void push(int node) {
        stack1.push(node);
    }

    int pop() {
        if(stack2.empty()){
            while(!stack1.empty()){
                stack2.push(stack1.top());
                stack1.pop();
            }
        }
        int node = stack2.top();
        stack2.pop();
        return node;
    }

private:
    stack<int> stack1;
    stack<int> stack2;
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 11
* 跳台阶

考察次数 55

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int jumpFloor(int number) {
        int a = 1 , b = 1 , c = 1;
        for (int i = 2 ; i <= number ; i ++) {
            c = a+b , a = b , b = c;
        }
        return c;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 12
* 链表中的节点每k个一组翻转

考察次数 53

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
  public:
    ListNode* reverseKGroup(ListNode* head, int k) {
         //找到每次翻转的尾部 fast-template
        ListNode* tail = head;
        //遍历k次到尾部
        for (int i = 0; i < k; i++) {
           //如果不足k到了链表尾，直接返回，不翻转
            if (tail == NULL)
                return head;
            tail = tail->next;
        }
        //翻转时需要的前序和当前节点
        ListNode* pre = NULL;
        ListNode* cur = head;
       //在到达当前段尾节点前
        while (cur != tail) {
            //翻转
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
       //当前尾指向下一段要翻转的链表
        head->next = reverseKGroup(tail,
                                   k);
        return pre;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 13
* 	连续子数组的最大和

考察次数 53

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int FindGreatestSumOfSubArray(vector<int> array) {
        vector<int>dp(array.size(),0);
        dp[0] = array[0];
        int res=array[0];
        for(int i=1;i<array.size();i++){
            dp[i]=max(array[i]+dp[i-1],array[i]);
            res= max(res,dp[i]);
        }
        return res;
    
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 14
* 最长无重复子数组

考察次数 52

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
  public:
    int maxLength(vector<int>& arr) {
        //哈希表记录窗口内非重复的数字 fast-template
        unordered_map<int, int> mp;
        int res = 0;
        //设置窗口左右边界
        for (int left = 0, right = 0; right < arr.size(); right++) {
            //窗口右移进入哈希表统计出现次数
            mp[arr[right]]++;
            //出现次数大于1，则窗口内有重复
            while (mp[arr[right]] > 1)
                //窗口左移，同时减去该数字的出现次数
                mp[arr[left++]]--;
            //维护子数组长度最大值
            res = max(res, right - left + 1);
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 15
* 判断链表中是否有环

考察次数 50

描述
```

```
<!-- ![img]() -->
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head) return false;
        ListNode* fast=head;
        ListNode* slow=head;
        while(fast&&fast->next){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow) return true;
        }
        return false;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 16
* 合并两个有序的数组

考察次数 49

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        //指向数组A的结尾 fast-template
        int i = m - 1;
        //指向数组B的结尾
        int j = n - 1;
        //指向数组A空间的结尾处
        int k = m + n - 1;
        //从两个数组最大的元素开始，直到某一个数组遍历完
        while(i >= 0 && j >= 0){
            //将较大的元素放到最后
            if(A[i] > B[j])
                A[k--] = A[i--];
            else
                A[k--] = B[j--];
        }
        //数组A遍历完了，数组B还有，则还需要添加到数组A前面
        if(i < 0){
            while(j >= 0)
                A[k--] = B[j--];
        //数组B遍历完了，数组A前面正好有，不用再添加
        }
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 17
* 链表中环的入口结点

考察次数 46

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
  public:
    //判断有没有环，返回相遇的地方 fast-template
    ListNode* hasCycle(ListNode* head) {
        //先判断链表为空的情况
        if (head == NULL)
            return NULL;
        //快慢双指针
        ListNode* fast = head;
        ListNode* slow = head;
        //如果没环快指针会先到链表尾
        while (fast != NULL && fast->next != NULL) {
            //快指针移动两步
            fast = fast->next->next;
            //慢指针移动一步
            slow = slow->next;
            //相遇则有环
            if (fast == slow)
                //返回相遇的地方
                return slow;
        }
        //到末尾则没有环
        return NULL;
    }
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* slow = hasCycle(pHead);
        //没有环
        if (slow == NULL)
            return NULL;
        //快指针回到表头
        ListNode* fast = pHead;
        //再次相遇即是环入口
        while (fast != slow) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 18
* 有效括号序列

考察次数 50

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    bool isValid(string s) {
         //辅助栈 fast-template
        stack<char> st;
         //遍历字符串
        for(int i = 0; i < s.length(); i++){
             //遇到左小括号
            if(s[i] == '(')
                //期待遇到右小括号
                st.push(')');
            //遇到左中括号
            else if(s[i] == '[')
                //期待遇到右中括号
                st.push(']');
            //遇到左打括号
            else if(s[i] == '{')
                //期待遇到右打括号
                st.push('}');
            //必须有左括号的情况下才能遇到右括号
            else if(st.empty())
                return false;
             //右括号匹配则弹出
            else if(st.top() == s[i])
                st.pop();
        }
        //栈中是否还有元素
        return st.empty();
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 19
* 删除链表的倒数第n个节点

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) { 
         //添加表头 fast-template
        ListNode* res = new ListNode(-1);
        res->next = head;
        //前序节点
        ListNode* pre = res;
        ListNode* fast = head;
        //快指针先行n步
        while(n--)
            fast = fast->next;
        //快慢指针同步，快指针到达末尾，慢指针就到了倒数第n个位置
        while(fast != NULL){
            fast = fast->next;
            pre=pre->next;
        }
        //删除该位置的节点
        pre->next = pre->next->next;
        //返回去掉头
        return res->next;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 20
* 大数加法

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
  public:
    string solve(string s, string t) {
        //若是其中一个为空，返回另一个 fast-template
        if (s.empty())
            return t;
        if (t.empty())
            return s;
        //让s为较长的，t为较短的
        if (s.length() < t.length())
            swap(s, t);
        //进位标志
        int carry = 0;
        //从后往前遍历较长的字符串
        for (int i = s.length() - 1; i >= 0; i--) {
            //转数字加上进位
            int temp = s[i] - '0' + carry;
            //转较短的字符串相应的从后往前的下标
            int j = i - s.length() + t.length();
            //如果较短字符串还有
            if (j >= 0)
                //转数组相加
                temp += t[j] - '0';
            //取进位
            carry = temp / 10;
            //去十位
            temp = temp % 10;
            //修改结果
            s[i] = temp + '0';
        }
        //最后的进位
        if (carry == 1)
            s = '1' + s;
        return s;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 21
* 按之字形顺序打印二叉树

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL)
            //如果是空，则直接返回空vector fast-template
            return res;
        //队列存储，进行层次遍历
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* cur;
        bool need_reverse=true;
        while(!q.empty()){
            //记录二叉树的某一行
            vector<int> row;
            int n = q.size();
            need_reverse = !need_reverse;
            //因先进入的是根节点，故每层结点多少，队列大小就是多少
            for(int i = 0; i < n; i++){
                cur = q.front();
                q.pop();
                row.push_back(cur->val);
                //若是左右孩子存在，则存入左右孩子作为下一个层次
                if(cur->left)
                    q.push(cur->left);
                if(cur->right)
                    q.push(cur->right);
            }
            //每一层加入输出
            if(need_reverse){
                reverse(row.begin(), row.end());
            }
            res.push_back(row);
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 22
* 最长公共子串

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
  public:
    string LCS(string str1, string str2) {
        //dp[i][j]表示到str1第i个个到str2第j个为止的公共子串长度 fast-template
        vector<vector<int> > dp(str1.length() + 1, vector<int>(str2.length() + 1, 0));
        int max = 0;
        int pos = 0;
        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                //如果该两位相同
                if (str1[i - 1] == str2[j - 1]) {
                    //则增加长度
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                //否则
                else {
                    //该位置为0
                    dp[i][j] = 0;
                }
                //更新最大长度
                if (dp[i][j] > max) {
                    max = dp[i][j];
                    pos = i - 1;
                }
            }
        }
        return str1.substr(pos - max + 1, max);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 23
* 两个链表的第一个公共结点

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    int getLength(ListNode* pHead){
        ListNode* cur = pHead;
        int n=0;
        while(cur!= NULL){
            cur=cur->next;
            n++;
        }
        return n;
    }
    ListNode* FindFirstCommonNode( ListNode* pHead1, ListNode* pHead2) {
        int len1=getLength(pHead1);
        int len2 = getLength(pHead2);
        int move = abs(len1-len2);
        while(move--){
            if(len1>len2){
                pHead1=pHead1->next;
            }
            else{
                pHead2=pHead2->next;
            }
        }
        while(pHead1&&pHead2&&pHead1!=pHead2){
            pHead1=pHead1->next;
            pHead2=pHead2->next;
        }
        return pHead1;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 24
* 链表相加(二)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        // write code here
        if(!head1){
            return head2;
        }
        if(!head2){
            return head1;
        }
        head1= reverseList(head1);
        head2= reverseList(head2);
        ListNode* res = new ListNode(-1);
        ListNode* cur=res;
        int carry =0;
        while(head1||head2||carry){
            int val1=0,val2=0;
            if(head1) {
                val1=head1->val;
                head1=head1->next;
            }                         
            
            if(head2){
                val2=head2->val;
                head2=head2->next;
            } 
            int temp=val1+val2+carry;
            carry=temp/10;
            temp %=10;
            ListNode* p=new ListNode(temp);
            cur->next=p;
            cur=cur->next;
        }
        return reverseList(res->next);
    }
    
    ListNode* reverseList(ListNode* head){
        if(head==NULL){
            return NULL;
        }
        ListNode* cur= head;
        ListNode* pre=NULL;
        while(cur){
            ListNode* temp=cur->next;
            cur->next=pre;
            pre=cur;
            cur=temp;
        }
        return pre;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 25
* 在二叉树中找到两个节点的最近公共祖先

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    //记录是否找到到o的路径 fast-template
    bool flag = false;
    //求得根节点到目标节点的路径
    void dfs(TreeNode* root, vector<int>& path, int o){
        if(flag || root == NULL)
            return;
        path.push_back(root->val);
        //节点值都不同，可以直接用值比较
        if(root->val == o){
            flag = true;
            return;
        }
        //dfs遍历查找
        dfs(root->left, path, o);
        dfs(root->right, path, o);
        if(flag)
            return;
        //该子树没有，回溯
        path.pop_back();
    }
    int lowestCommonAncestor(TreeNode* root, int o1, int o2) {
        vector<int> path1, path2;
        //求根节点到两个节点的路径
        dfs(root, path1, o1);
        //重置flag
        flag = false;
        dfs(root, path2, o2);
        int res ;
        //比较两个路径，找到第一个不同的点
        for(int i = 0; i < path1.size() && i < path2.size(); i++){
            if(path1[i] == path2[i])
                //最后一个相同的节点就是最近公共祖先
                res = path1[i];
            else
                break;
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 26
* 反转字符串

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    string solve(string str) {
    //左右双指针 fast-template
        int left = 0;
        int right = str.length() - 1;
        //两指针往中间靠
        while(left < right){
            //交换两边字符
            swap(str[left], str[right]);
            left++;
            right--;
        }
        return str;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 27
*  螺旋矩阵

考察次数 031

描述
```
给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。

数据范围：0 \le n,m \le 100≤n,m≤10，矩阵中任意元素都满足 |val| \le 100∣val∣≤100
要求：空间复杂度 O(nm)O(nm) ，时间复杂度 O(nm)O(nm)
```
<!-- ![img]() -->
```cpp
class Solution {
  public:
    vector<int> spiralOrder(vector<vector<int> >& matrix) {
        vector<int> res;
        int n = matrix.size();
        //先排除特殊情况 fast-template
        if (n == 0)
            return res;
        //左边界
        int left = 0;
        //右边界
        int right = matrix[0].size() - 1;
        //上边界
        int up = 0;
        //下边界
        int down = n - 1;
        //直到边界重合
        while (left <= right && up <= down) {
            //上边界的从左到右
            for (int i = left; i <= right; i++)
                res.push_back(matrix[up][i]);
            //上边界向下
            up++;
            if (up > down)
                break;
            //右边界的从上到下
            for (int i = up; i <= down; i++)
                res.push_back(matrix[i][right]);
            //右边界向左
            right--;
            if (left > right)
                break;
            //下边界的从右到左
            for (int i = right; i >= left; i--)
                res.push_back(matrix[down][i]);
            //下边界向上
            down--;
            if (up > down)
                break;
            //左边界的从下到上
            for (int i = down; i >= up; i--)
                res.push_back(matrix[i][left]);
            //左边界向右
            left++;
            if (left > right)
                break;
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 28
* 斐波那契数列

考察次数 031

描述
```

```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int Fibonacci(int n) {
        //从0开始，第0项是0，第一项是1 fast-template
        if(n <= 1)
             return n;
         int res = 0;
         int a = 0;
         int b = 1;
        //因n=2时也为1，初始化的时候把a=0，b=1
         for (int i = 2; i <= n; i++){
         //第三项开始是前两项的和,然后保留最新的两项，更新数据相加
             res = (a + b);
             a = b;
             b = res;
         }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 29
* 最长回文子串

考察次数 030

描述
```
对于长度为n的一个字符串A（仅包含数字，大小写英文字母），请设计一个高效算法，计算其中最长回文子串的长度。


数据范围： 1 \le n \le 10001≤n≤1000
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n^2)O(n 
2
 )
进阶:  空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int fun(string& s, int begin, int end){
        //每个中心点开始扩展 fast-template
        while(begin >= 0 && end < s.length() && s[begin] == s[end]){
            begin--;
            end++;
        }
        //返回长度
        return end - begin - 1;
    }
    int getLongestPalindrome(string A) {
        int maxlen = 1;
         //以每个点为中心
        for(int i = 0; i < A.length() - 1; i++)
            //分奇数长度和偶数长度向两边扩展
            maxlen = max(maxlen, max(fun(A, i, i), fun(A, i, i + 1)));
        return maxlen;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 30
* 三数之和

考察次数 031

描述
```
给出一个有n个元素的数组S，S中是否有元素a,b,c满足a+b+c=0？找出数组S中所有满足条件的三元组。

数据范围：0 \le n \le 30000≤n≤3000，数组中各个元素值满足 |val | \le 100∣val∣≤100
空间复杂度：O(n^2)O(n 
2
 )，时间复杂度 O(n^2)O(n 
2
 )

注意：
三元组（a、b、c）中的元素可以按任意顺序排列。
解集中不能包含重复的三元组。
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        vector<vector<int> > res;
        int n = num.size();
        //不够三元组 fast-template
        if(n < 3)
            return res;
        //排序
        sort(num.begin(), num.end());
        for(int i = 0; i < n - 2; i++){
            if(i != 0 && num[i] == num[i - 1])
                continue;
            //后续的收尾双指针
            int left = i + 1;
            int right = n - 1;
            //设置当前数的负值为目标
            int target = -num[i];
            while(left < right){
                //双指针指向的二值相加为目标，则可以与num[i]组成0
                if(num[left] + num[right] == target){
                    res.push_back({num[i], num[left], num[right]});
                    while(left + 1 < right && num[left] == num[left + 1])
                        //去重
                        left++;
                    while(right - 1 > left && num[right] == num[right - 1])
                        //去重
                        right--;
                    //双指针向中间收缩
                    left++;
                    right--;
                }
                //双指针指向的二值相加大于目标，右指针向左
                else if(num[left] + num[right] > target)
                    right--;
                //双指针指向的二值相加小于目标，左指针向右
                else left++;
            }
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 31
* 重建二叉树

考察次数 030

描述
```
给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。
例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示。
```
![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626504921458/776B0E5E0FAD11A6F15004B29DA5E628)
```cpp
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        int n = pre.size();
        int m = vin.size();
        //每个遍历都不能为0 fast-template
        if(n == 0 || m == 0)
            return NULL;
        //构建根节点
        TreeNode *root = new TreeNode(pre[0]);
        for(int i = 0; i < vin.size(); i++){
             //找到中序遍历中的前序第一个元素
            if(pre[0] == vin[i]){
                //左子树的前序遍历
                vector<int> leftpre(pre.begin() + 1, pre.begin() + i + 1);
                //左子树的中序遍历
                vector<int> leftvin(vin.begin(), vin.begin() + i);
                 //构建左子树
                root->left = reConstructBinaryTree(leftpre, leftvin);
                //右子树的前序遍历
                vector<int> rightpre(pre.begin() + i + 1, pre.end());
                //右子树的中序遍历
                vector<int> rightvin(vin.begin() + i + 1, vin.end());
                 //构建右子树
                root->right = reConstructBinaryTree(rightpre, rightvin);
                break;
            }
        }
        return root;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 32
* 最长上升子序列（三）

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 33
* 求平方根

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 34
* 在旋转过的有序数组中寻找目标值

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 35
* 包含min函数的栈

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 36
* 买卖股票的最好时机(一)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 37
* 合并k个已排序的链表

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 38
* 字符串的排列

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 39
* 接雨水问题

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 40
* 输出二叉树的右视图

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 41
* 岛屿数量

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 42
* 二叉树的最大深度

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 43
* 判断是否为回文字符串

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 44
* 单链表的排序

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 45
* 判断是不是平衡二叉树

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 46
* 数组中出现次数超过一半的数字

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 47
* 矩阵的最小路径和

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 48
* 表达式求值

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 49
* 字符串出现次数的TopK问题

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 50
* 进制转换

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>



## TOP51-100

### 51
* 判断一个链表是否为回文结构

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 52
* 编辑距离(二)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 53
* 二叉树根节点到叶子节点的所有路径和

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 54
* 二叉树中和为某一值的路径(二)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 55
* 链表内指定区间反转

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 56
* 不同路径的数目(一)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 57
* 合并区间

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 58
* 最长公共子序列(二)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 59
* 在两个长度相等的排序数组中找到上中位数

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 60
*  判断一棵二叉树是否为搜索二叉树和完全二叉树

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 61
* 删除有序链表中重复的元素-II

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 62
* 把字符串转换成整数(atoi)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 63
* 反转数字

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 64
* 矩阵元素查找

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 65
* 缺失的第一个正整数

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 66
* 链表的奇偶重排

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 67
* 二叉树中的最大路径和

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 68
* 对称的二叉树

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 69
* 括号生成

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 70
* 顺时针旋转矩阵

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 71
* 数字字符串转化成IP地址

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 72
* 设计LFU缓存结构

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 73
* 重排链表

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 74
* 删除有序链表中重复的元素-I

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 75
* 有重复项数字的全排列

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 76
* 滑动窗口的最大值

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 77
* 二叉树中和为某一值的路径(一)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 78
* 加起来和为目标值的组合(二)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 79
* 最长的括号子串

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 80
* 最长公共前缀

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 81
* 回文数字

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 82
* 二分查找-II

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 83
* 丢棋子问题

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 84
* 序列化二叉树

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 85
* 二叉搜索树的第k个节点

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 86
* 字符串变形

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 87
* 数组中的最长连续子序列

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 88
* 环形链表的约瑟夫问题

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 89
* 多叉树的直径

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 90
* 最大数

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 91
* 验证IP地址

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 92
* 大数乘法

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 93
* 集合的所有子集(一)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 94
* 没有重复项数字的全排列

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 95
* 链表中倒数最后k个结点

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 96
* 兑换零钱(一)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 97
* 寻找峰值

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 98
* 最小覆盖子串

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 99
* 二维数组中的查找

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 100
* 数组中的逆序对

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>



## TOP101-150

### 101
* 二进制中1的个数

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 102
* 最大正方形

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 103
* 旋转数组

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 104
* 正则表达式匹配

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 105
* 数据流中的中位数

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 106
* N皇后问题

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 107
* 字典树的实现

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 108
* 把二叉树打印成多行

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 109
* 连续子数组的最大乘积

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 110
* 把数字翻译成字符串

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 111
* 买卖股票的最好时机(二)

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 112
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 113
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 114
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 115
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 116
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 117
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 118
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 119
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 120
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 121
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 122
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 123
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 124
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 125
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 126
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 127
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 128
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 129
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 130
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 131
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 132
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 133
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 134
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 135
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 136
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 137
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 138
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 139
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 140
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 141
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 142
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 143
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 144
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 145
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 146
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 147
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 148
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 149
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### 150
* dosomething

考察次数 000

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

