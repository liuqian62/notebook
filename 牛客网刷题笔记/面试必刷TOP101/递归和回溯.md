# 递归和回溯

## 目录

- [BM55](#BM55)
- [BM56](#BM56)
- [BM57](#BM57)
- [BM58](#BM58)
- [BM59](#BM59)
- [BM60](#BM60)
- [BM61](#BM61)



## BM55
* BM55 没有重复项数字的全排列

描述
```
给出一组数字，返回该组数字的所有排列
例如：
[1,2,3]的所有排列如下
[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2], [3,2,1].
（以数字在数组中的位置靠前为优先级，按字典序排列输出。）

数据范围：数字个数 0 < n \le 60<n≤6
要求：空间复杂度 O(n!)O(n!) ，时间复杂度 O(n!）O(n!）
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    void dfs(vector<int>& tmp,vector<bool>& used,vector<int> num,vector<vector<int>>& res){
        int n= num.size();
        if(tmp.size()==n){
            res.push_back(tmp);
            return;
        }
        for(int i=0;i< n;i++){
            if(!used[i]){
                used[i]=true;
                tmp.push_back(num[i]);
                dfs(tmp,used,num,res);
                tmp.pop_back();
                used[i]=false;
            }
        }
    }
    vector<vector<int> > permute(vector<int> &num) {
        vector<int>tmp;
        vector<bool>used(num.size(),false);
        vector<vector<int>> res;
        dfs(tmp,used,num,res);
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM56
* BM56 有重复项数字的全排列

描述
```
给出一组可能包含重复项的数字，返回该组数字的所有排列。结果以字典序升序排列。

数据范围： 0 < n \le 80<n≤8 ，数组中的值满足 -1 \le val \le 5−1≤val≤5
要求：空间复杂度 O(n!)O(n!)，时间复杂度 O(n!)O(n!)
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    vector<vector<int> > permuteUnique(vector<int> &num) {
        vector<vector<int>> res;
        sort(num.begin(),num.end());
        vector<int > tmp;
        vector<bool> used(num.size(),false);
        dfs(tmp,num,used,res);
        return res;
        
    }
    void dfs(vector<int>& tmp,vector<int> num, vector<bool>& used,vector<vector<int>>& res){
        if(tmp.size()==num.size()){
            res.push_back(tmp);
            return;
        }
        for(int i=0;i< num.size();i++){
            if(used[i]) continue;
            if(i!=0&&num[i]==num[i-1]&&used[i-1]) continue;
            used[i]=true;
            tmp.push_back(num[i]);
            dfs(tmp,num,used,res);
            tmp.pop_back();
            used[i]=false;
        }
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM57
* BM57 岛屿数量

描述
```
给一个01矩阵，1代表是陆地，0代表海洋， 如果两个1相邻，那么这两个1属于同一个岛。我们只考虑上下左右为相邻。
岛屿: 相邻陆地可以组成一个岛屿（相邻:上下左右） 判断岛屿个数。
例如：
输入
[
[1,1,0,0,0],
[0,1,0,1,1],
[0,0,0,1,1],
[0,0,0,0,0],
[0,0,1,1,1]
]
对应的输出为3
(注：存储的01数据其实是字符'0','1')
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    //深度优先遍历与i，j相邻的所有1 fast-template
    void dfs(vector<vector<char>>& grid, int i, int j) {
        int n = grid.size();
        int m = grid[0].size();
        // 置为0
        grid[i][j] = '0';
        //后续四个方向遍历
        if(i - 1 >= 0 && grid[i - 1][j] == '1')
            dfs(grid, i - 1, j);
        if(i + 1 < n && grid[i + 1][j] == '1')
            dfs(grid, i + 1,j);
        if(j - 1 >= 0 && grid[i][j - 1] == '1')
            dfs(grid, i, j - 1);
        if(j + 1 < m && grid[i][j + 1] == '1')
            dfs(grid, i, j + 1);
    }
    int solve(vector<vector<char> >& grid) {
        int n = grid.size();
        //空矩阵的情况
        if (n == 0)
            return 0;
        int m = grid[0].size();
        //记录岛屿数
        int count = 0;
         // 遍历矩阵
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                //遍历到1的情况
                if(grid[i][j] == '1'){
                    //计数
                    count++;
                    //将与这个1相邻的所有1置为0
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM58
* BM58 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM59
* BM59 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM60
* BM60 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM61
* BM61 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

