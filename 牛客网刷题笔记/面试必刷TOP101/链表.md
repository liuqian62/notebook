# 链表
* BM1 反转链表

描述：`给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。
数据范围： 0\leq n\leq10000≤n≤1000
要求：空间复杂度 O(1)O(1) ，时间复杂度 O(n)O(n) 。
如当输入链表{1,2,3}时，
经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。
以上转换过程如下图所示：`  
![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249)

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr){
            return nullptr;
        }
        ListNode* cur=pHead;
        ListNode* pre=NULL;
        while(cur!=NULL){
            ListNode* tmp = cur->next;
            cur->next=pre;
            pre=cur;
            cur=tmp;
        }
        return pre;

    }
};
```
* BM2 链表内指定区间反转

描述：`将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)O(n)，空间复杂度 O(1)O(1)。
例如：
给出的链表为 1\to 2 \to 3 \to 4 \to 5 \to NULL1→2→3→4→5→NULL, m=2,n=4m=2,n=4,
返回 1\to 4\to 3\to 2\to 5\to NULL1→4→3→2→5→NULL.
数据范围： 链表长度 0 < size \le 10000<size≤1000，0 < m \le n \le size0<m≤n≤size，链表中每个节点的值满足 |val| \le 1000∣val∣≤1000
要求：时间复杂度 O(n) ，空间复杂度 O(n)
进阶：时间复杂度 O(n)，空间复杂度 O(1)`  
<!-- ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249) -->

```cpp
/*
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        // write code here
        ListNode* res = new ListNode(-1);
        res->next=head;
        ListNode* pre=res;
        ListNode* cur=head;
        for(int i =1; i<m; i++){
            pre =cur;
            cur = cur->next;
        }
        for(int i=m;i<n;i++){
            ListNode* temp = cur->next;
            cur->next=temp->next;
            temp->next=pre->next;
            pre->next=temp;
        }
        return res->next;
    }
```
* BM3 链表中的节点每K个一组翻转

描述：`将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。
数据范围：  0≤n≤2000 ， 1≤k≤2000 ，链表中每个元素都满足0≤val≤1000
要求空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)
例如：
给定的链表是 1\to2\to3\to4\to51→2→3→4→5
对于 k = 2k=2 , 你应该返回 2\to 1\to 4\to 3\to 52→1→4→3→5
对于 k = 3k=3 , 你应该返回 3\to2 \to1 \to 4\to 53→2→1→4→5`  
<!-- ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249) -->

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* reverseKGroup(ListNode* head, int k) {
        // write code here
        ListNode* p = head;
        for(int i=0;i<k;i++){
            if(p==NULL){
                return head;
            }
            p=p->next;
        }
        ListNode* pre=NULL;
        ListNode* cur=head;
        while(cur!=p){
            ListNode* temp=cur->next;
            cur->next=pre;
            pre=cur;
            cur=temp;
            
            
        }
        head->next=reverseKGroup(p,  k) ;
        return pre;
    }
};
```
* BM4 合并两个排序的链表

描述：`输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。
数据范围： 0≤n≤1000，−1000≤节点值≤1000
要求：空间复杂度O(1)，时间复杂度 O(n)
如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：`  
![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208575589/09DD8C2662B96CE14928333F055C5580)

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(pHead1==NULL){
            return pHead2;
        }
        if(pHead2 ==NULL){
            return pHead1;
        }
        ListNode* head = new ListNode(-1);
        ListNode* cur =head;
        while(pHead1&&pHead2){
            if(pHead1->val>=pHead2->val){
                cur->next=pHead2;
                pHead2=pHead2->next;                
            }
            else{
                cur->next=pHead1;
                pHead1=pHead1->next;
            }
            cur =cur->next;
        }
        if(pHead1){
            cur->next=pHead1;
        }else{
            cur->next=pHead2;
        }
        return head->next;
    }
};
```
* BM5 合并k个已经排序的链表

描述：`合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。
数据范围：节点总数满足 0 ≤n≤10 ^5
 ，链表个数满足 1≤k≤10 ^5
   ，每个链表的长度满足1≤len≤200  ，每个节点的值满足 ∣val∣<=1000
要求：时间复杂度 O(nlogk)`  
<!-- ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208575589/09DD8C2662B96CE14928333F055C5580)
 -->
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        return devideMerge(lists, 0,lists.size()-1);
    }
    
    ListNode* devideMerge(vector<ListNode*> &lists,int left,int right){
        if(left>right){
            return NULL;
        }
        if(left==right){
            return lists[left];
        }
        int mid=(left+right)/2;
        return mergeTwo(devideMerge(lists,left,mid), devideMerge(lists,mid+1,right));
        
    
    
    }
ListNode* mergeTwo(ListNode* pHead1,ListNode* pHead2){
        ListNode* head=new ListNode(-1);
        ListNode* cur =head;
        while(pHead1&&pHead2){
            if(pHead1->val>=pHead2->val){
                cur->next=pHead2;
                pHead2=pHead2->next;
            }else{
                cur->next=pHead1;
                pHead1=pHead1->next;
            }
            cur=cur->next;
        }    
            if(pHead1){
                cur->next=pHead1;
            }else{
                cur->next=pHead2;
            }
            return head->next;
            
        }
};
```

* BM6 判断链表中是否有环

描述：
```
判断给定的链表中是否有环。如果有环则返回true，否则返回false。


数据范围：链表长度 0 \le n \le 100000≤n≤10000，链表中任意节点的值满足 |val| <= 100000∣val∣<=100000
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)

输入分为两部分，第一部分为链表，第二部分代表是否有环，然后将组成的head头结点传入到函数里面。-1代表无环，其它的数字代表有环，这些参数解释仅仅是为了方便读者自测调试。实际在编程时读入的是链表的头节点。

例如输入{3,2,0,-4},1时，对应的链表结构如下图所示：
```  
![img](https://uploadfiles.nowcoder.com/images/20220110/423483716_1641800950920/0710DD5D9C4D4B11A8FA0C06189F9E9C)
解题思路
```
我们使用两个指针，fast 与 slow。
它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。
```
![silu](https://uploadfiles.nowcoder.com/images/20210705/889362376_1625450984750/90F3D92D3E9DA027A495E49CFBFEC150)
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow =head;
        while(fast!=NULL&&fast->next!= NULL){
            fast=fast->next->next;
            slow= slow->next;
            if(fast==slow){
                return true;
            }
            
        }
        return false;
    }
};
```
* BM7 链表中环的入口结点

描述：
```
给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。

数据范围： n\le10000n≤10000，1<=结点值<=100001<=结点值<=10000
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)

例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：
```
![img](https://uploadfiles.nowcoder.com/images/20211025/423483716_1635154005498/DA92C945EF643F1143567935F20D6B46)
解题思路：
```
方法1：hash法，记录第一次重复的结点
通过使用set或者map来存储已经遍历过的结点，当第一次出现重复的结点时，即为入口结点。

方法2：快慢指针
通过定义slow和fast指针，slow每走一步，fast走两步，若是有环，则一定会在环的某个结点处相遇（slow == fast），根据下图分析计算，可知从相遇处到入口结点的距离与头结点与入口结点的距离相同。
```
```cpp
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* hasLoop(ListNode* pHead){
        if (pHead==NULL){
            return NULL;
        }
        ListNode* fast = pHead;
        ListNode* slow = pHead;
        while(fast!=NULL&&fast->next!=NULL){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow){
                return slow;
            }
               
        }
               return NULL;
    }
    ListNode* EntryNodeOfLoop(ListNode* pHead) {
        ListNode* slow = hasLoop(pHead);
        ListNode* fast = pHead;
        if(slow==NULL){
            return NULL;
        }
        while(fast!=slow){
            fast=fast->next;
            slow=slow->next;
            
        }
        return slow;
      
        

    }
```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
