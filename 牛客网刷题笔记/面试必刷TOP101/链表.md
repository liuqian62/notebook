# 链表
* BM1 反转链表

描述：`给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。
数据范围： 0\leq n\leq10000≤n≤1000
要求：空间复杂度 O(1)O(1) ，时间复杂度 O(n)O(n) 。
如当输入链表{1,2,3}时，
经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。
以上转换过程如下图所示：`  
![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249)

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr){
            return nullptr;
        }
        ListNode* cur=pHead;
        ListNode* pre=NULL;
        while(cur!=NULL){
            ListNode* tmp = cur->next;
            cur->next=pre;
            pre=cur;
            cur=tmp;
        }
        return pre;

    }
};
```
* BM2 链表内指定区间反转

描述：`将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 O(n)O(n)，空间复杂度 O(1)O(1)。
例如：
给出的链表为 1\to 2 \to 3 \to 4 \to 5 \to NULL1→2→3→4→5→NULL, m=2,n=4m=2,n=4,
返回 1\to 4\to 3\to 2\to 5\to NULL1→4→3→2→5→NULL.
数据范围： 链表长度 0 < size \le 10000<size≤1000，0 < m \le n \le size0<m≤n≤size，链表中每个节点的值满足 |val| \le 1000∣val∣≤1000
要求：时间复杂度 O(n) ，空间复杂度 O(n)
进阶：时间复杂度 O(n)，空间复杂度 O(1)`  
<!-- ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249) -->

```cpp
/*
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        // write code here
        ListNode* res = new ListNode(-1);
        res->next=head;
        ListNode* pre=res;
        ListNode* cur=head;
        for(int i =1; i<m; i++){
            pre =cur;
            cur = cur->next;
        }
        for(int i=m;i<n;i++){
            ListNode* temp = cur->next;
            cur->next=temp->next;
            temp->next=pre->next;
            pre->next=temp;
        }
        return res->next;
    }
```
* BM3 链表中的节点每K个一组翻转

描述：`将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。
数据范围：  0≤n≤2000 ， 1≤k≤2000 ，链表中每个元素都满足0≤val≤1000
要求空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)
例如：
给定的链表是 1\to2\to3\to4\to51→2→3→4→5
对于 k = 2k=2 , 你应该返回 2\to 1\to 4\to 3\to 52→1→4→3→5
对于 k = 3k=3 , 你应该返回 3\to2 \to1 \to 4\to 53→2→1→4→5`  
<!-- ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206291971/4A47A0DB6E60853DEDFCFDF08A5CA249) -->

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 * };
 */

class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* reverseKGroup(ListNode* head, int k) {
        // write code here
        ListNode* p = head;
        for(int i=0;i<k;i++){
            if(p==NULL){
                return head;
            }
            p=p->next;
        }
        ListNode* pre=NULL;
        ListNode* cur=head;
        while(cur!=p){
            ListNode* temp=cur->next;
            cur->next=pre;
            pre=cur;
            cur=temp;
            
            
        }
        head->next=reverseKGroup(p,  k) ;
        return pre;
    }
};
```
* BM4 合并两个排序的链表

描述：`输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。
数据范围： 0≤n≤1000，−1000≤节点值≤1000
要求：空间复杂度O(1)，时间复杂度 O(n)
如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：`  
![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208575589/09DD8C2662B96CE14928333F055C5580)

```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(pHead1==NULL){
            return pHead2;
        }
        if(pHead2 ==NULL){
            return pHead1;
        }
        ListNode* head = new ListNode(-1);
        ListNode* cur =head;
        while(pHead1&&pHead2){
            if(pHead1->val>=pHead2->val){
                cur->next=pHead2;
                pHead2=pHead2->next;                
            }
            else{
                cur->next=pHead1;
                pHead1=pHead1->next;
            }
            cur =cur->next;
        }
        if(pHead1){
            cur->next=pHead1;
        }else{
            cur->next=pHead2;
        }
        return head->next;
    }
};
```
* BM5 合并k个已经排序的链表

描述：`合并 k 个升序的链表并将结果作为一个升序的链表返回其头节点。
数据范围：节点总数满足 0 ≤n≤10 ^5
 ，链表个数满足 1≤k≤10 ^5
   ，每个链表的长度满足1≤len≤200  ，每个节点的值满足 ∣val∣<=1000
要求：时间复杂度 O(nlogk)`  
<!-- ![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634208575589/09DD8C2662B96CE14928333F055C5580)
 -->
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        return devideMerge(lists, 0,lists.size()-1);
    }
    
    ListNode* devideMerge(vector<ListNode*> &lists,int left,int right){
        if(left>right){
            return NULL;
        }
        if(left==right){
            return lists[left];
        }
        int mid=(left+right)/2;
        return mergeTwo(devideMerge(lists,left,mid), devideMerge(lists,mid+1,right));
        
    
    
    }
ListNode* mergeTwo(ListNode* pHead1,ListNode* pHead2){
        ListNode* head=new ListNode(-1);
        ListNode* cur =head;
        while(pHead1&&pHead2){
            if(pHead1->val>=pHead2->val){
                cur->next=pHead2;
                pHead2=pHead2->next;
            }else{
                cur->next=pHead1;
                pHead1=pHead1->next;
            }
            cur=cur->next;
        }    
            if(pHead1){
                cur->next=pHead1;
            }else{
                cur->next=pHead2;
            }
            return head->next;
            
        }
};
```

* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
* BMx dosomething

描述：``  
<!-- ![img]()
 -->
```cpp

```
