# 动态规划

## 目录

- [BM62](#BM62)
- [BM63](#BM63)
- [BM64](#BM64)
- [BM65](#BM65)
- [BM66](#BM66)
- [BM67](#BM67)
- [BM68](#BM68)
- [BM69](#BM69)
- [BM70](#BM70)
- [BM71](#BM71)
- [BM72](#BM72)
- [BM73](#BM73)
- [BM74](#BM74)
- [BM75](#BM75)
- [BM76](#BM76)
- [BM77](#BM77)
- [BM78](#BM78)
- [BM79](#BM79)
- [BM80](#BM80)
- [BM81](#BM81)
- [BM82](#BM82)



## BM62
* BM62 斐波那契数列

描述
```
大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。
斐波那契数列是一个满足 fib(x)=\left\{ \begin{array}{rcl} 1 & {x=1,2}\\ fib(x-1)+fib(x-2) &{x>2}\\ \end{array} \right.fib(x)={ 
1
fib(x−1)+fib(x−2)
​
  
x=1,2
x>2
​
  的数列
数据范围：1\leq n\leq 401≤n≤40
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n) ，本题也有时间复杂度 O(logn)O(logn) 的解法
```
<!-- ![img]() -->
```cpp
#方法一
class Solution {
public:
    int Fibonacci(int n) {
        if(n==1||n==2){
            return 1;
        }
        return Fibonacci(n-1)+Fibonacci(n-2);

    }
};
#方法二
class Solution {
public:
    int Fibonacci(int n) {
        //从0开始，第0项是0，第一项是1 fast-template
        if(n <= 1)
             return n;
         int res = 0;
         int a = 0;
         int b = 1;
        //因n=2时也为1，初始化的时候把a=0，b=1
         for (int i = 2; i <= n; i++){
         //第三项开始是前两项的和,然后保留最新的两项，更新数据相加
             res = (a + b);
             a = b;
             b = res;
         }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM63
* BM63 跳台阶

描述
```
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

数据范围：1 \leq n \leq 401≤n≤40
要求：时间复杂度：O(n)O(n) ，空间复杂度： O(1)O(1)
```
<!-- ![img]() -->
```cpp
#方法一
class Solution {
public:
    int jumpFloor(int number) {
        if(number==1){
            return 1;
        }
        if(number==2){
            return 2;
        }
        return jumpFloor(number-1)+jumpFloor(number-2);
        
    }
};
#方法二
class Solution {
public:
    int f[50]{0};
    int jumpFloor(int number) {
        if (number <= 1) return 1;
        if (f[number] > 0) return f[number];
        return f[number] = (jumpFloor(number-1)+jumpFloor(number-2));
    }
};
#方法三
class Solution {
public:
    int jumpFloor(int number) {
        int a = 1 , b = 1 , c = 1;
        for (int i = 2 ; i <= number ; i ++) {
            c = a+b , a = b , b = c;
        }
        return c;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM64
* BM64 最小花费爬楼梯

描述
```
给定一个整数数组 cost \cost  ，其中 cost[i]\cost[i]  是从楼梯第i \i 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

数据范围：数组长度满足 1 \le n \le 10^5 \1≤n≤10 
5
   ，数组中的值满足 1 \le cost_i \le 10^4 \1≤cost 
i
​
 ≤10 
4
  
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        //dp[i]表示爬到第i阶楼梯需要的最小花费 fast-template
        vector<int> dp(cost.size() + 1, 0);
        for(int i = 2; i <= cost.size(); i++)
            //每次选取最小的方案
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        return dp[cost.size()];
   }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM65
* BM65 最长公共子序列(二)

描述
```
给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

数据范围：0 \le |str1|,|str2| \le 20000≤∣str1∣,∣str2∣≤2000
要求：空间复杂度 O(n^2)O(n 
2
 ) ，时间复杂度 O(n^2)O(n 
2
 )
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    string x = "";
    string y = "";
    //获取最长公共子序列 fast-template
    string ans(int i, int j, vector<vector<int>>& b){
        string res = "";
        //递归终止条件
        if(i == 0 || j == 0)
            return res;
        //根据方向，往前递归，然后添加本级字符
        if(b[i][j] == 1){
            res += ans(i - 1, j - 1, b);
            res += x[i - 1];
        }
        else if(b[i][j] == 2){
            res += ans(i - 1, j, b);
        }
        else if(b[i][j] == 3)
            res += ans(i,j - 1, b);
        return res;
    }
    string LCS(string s1, string s2) {
        //特殊情况
        if(s1.length() == 0 || s2.length() == 0)
            return "-1";
        int len1 = s1.length();
        int len2 = s2.length();
        x = s1;
        y = s2;
        //dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        //动态规划数组相加的方向
        vector<vector<int>> b(len1 + 1, vector<int>(len2 + 1, 0));
        //遍历两个字符串每个位置
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                //遇到两个字符相等
                if(s1[i - 1] == s2[j - 1]){
                    //考虑由二者都向前一位
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    //来自于左上方
                    b[i][j] = 1;
                }
                //遇到的两个字符不同
                else{
                    //左边的选择更大，即第一个字符串后退一位
                    if(dp[i - 1][j] > dp[i][j - 1]){
                        dp[i][j] = dp[i - 1][j];
                        //来自于左方
                        b[i][j] = 2;
                    }
                    //右边的选择更大，即第二个字符串后退一位
                    else{
                        dp[i][j] = dp[i][j - 1];
                        //来自于上方
                        b[i][j] = 3;
                    }
                }
            }
        }
        //获取答案字符串
        string res = ans(len1, len2, b);
        //检查答案是否位空
        return  res != "" ? res : "-1";
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM66
* BM66 最长公共子串

描述
```
给定两个字符串str1和str2,输出两个字符串的最长公共子串
题目保证str1和str2的最长公共子串存在且唯一。 

数据范围： 1 \le |str1|,|str2| \le 50001≤∣str1∣,∣str2∣≤5000
要求： 空间复杂度 O(n^2)O(n 
2
 )，时间复杂度 O(n^2)O(n 
2
 )
```
<!-- ![img]() -->
```cpp
class Solution {
  public:
    string LCS(string str1, string str2) {
        //dp[i][j]表示到str1第i个个到str2第j个为止的公共子串长度 fast-template
        vector<vector<int> > dp(str1.length() + 1, vector<int>(str2.length() + 1, 0));
        int max = 0;
        int pos = 0;
        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                //如果该两位相同
                if (str1[i - 1] == str2[j - 1]) {
                    //则增加长度
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                //否则
                else {
                    //该位置为0
                    dp[i][j] = 0;
                }
                //更新最大长度
                if (dp[i][j] > max) {
                    max = dp[i][j];
                    pos = i - 1;
                }
            }
        }
        return str1.substr(pos - max + 1, max);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM67
* BM67 不同路径的数目(一)

描述
```
一个机器人在m×n大小的地图的左上角（起点）。
机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。
可以有多少种不同的路径从起点走到终点？
```
![img](https://uploadfiles.nowcoder.com/images/20201210/999991351_1607596327517/873CB1F2327F70DA0CA0FDC797F894A7)
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        //矩阵只要有一条边为1，路径数就只有一种了 fast-template
        if(m == 1 || n == 1)
            return 1;
        //两个分支
        return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM68
* BM68 矩阵的最小路径和

描述
```
给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。

数据范围: 1 \le n,m\le 5001≤n,m≤500，矩阵中任意值都满足 0 \le a_{i,j} \le 1000≤a 
i,j
​
 ≤100
要求：时间复杂度 O(nm)O(nm)

例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，
所选择的最小累加和路径如下图所示：
```
![img](https://uploadfiles.nowcoder.com/images/20220122/423483716_1642823916509/06EB123C153852AF55ED51448BEAD1BA)
```cpp
class Solution {
public:
    int minPathSum(vector<vector<int> >& matrix) {
        //因为n,m均大于等于1 fast-template
        int n = matrix.size();
        int m = matrix[0].size();
        vector<vector<int> > dp(n + 1, vector<int>(m + 1, 0));
        //dp[i][j]表示以当前i，j位置为终点的最短路径长度
        dp[0][0] = matrix[0][0];
        //处理第一列
        for(int i = 1; i < n; i++)
            dp[i][0] = matrix[i][0] + dp[i - 1][0];
        //处理第一行
        for(int j = 1; j < m; j++)
            dp[0][j] = matrix[0][j] + dp[0][j - 1];
        //其他按照公式来
        for(int i = 1; i < n; i++){
          for(int j = 1; j < m; j++){
              dp[i][j] = matrix[i][j] + (dp[i - 1][j] > dp[i][j - 1] ? dp[i][j - 1] : dp[i - 1][j]);
          }
      }
       return dp[n - 1][m - 1];
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM69
* BM69 把数字翻译成字符串

描述
```
有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。
我们把一个字符串编码成一串数字，再考虑逆向编译成字符串。
由于没有分隔符，数字编码成字母可能有多种编译结果，例如 11 既可以看做是两个 'a' 也可以看做是一个 'k' 。但 10 只可能是 'j' ，因为 0 不能编译成任何结果。
现在给一串数字，返回有多少种可能的译码结果

数据范围：字符串长度满足 0 < n \le 900<n≤90
进阶：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
```
![img](https://uploadfiles.nowcoder.com/images/20220330/397721558_1648642427026/00A76CA12306902C5E5628EFD49A6CBC)
```cpp
class Solution {
public:
    int solve(string nums) {
        //排除0
        if(nums == "0") 
            return 0;
        //排除只有一种可能的10 和 20
        if(nums == "10" || nums == "20") 
            return 1;
        //当0的前面不是1或2时，无法译码，0种
        for(int i = 1; i < nums.length(); i++){ 
            if(nums[i] == '0')
                if(nums[i - 1] != '1' && nums[i - 1] != '2')
                    return 0;
        }
        //辅助数组初始化为1
        vector<int> dp(nums.length() + 1, 1); 
        for(int i = 2; i <= nums.length(); i++){
            //在11-19，21-26之间的情况
            if((nums[i - 2] == '1' && nums[i - 1] != '0') || (nums[i - 2] == '2' && nums[i - 1] > '0' && nums[i - 1] < '7'))
               dp[i] = dp[i - 1] + dp[i - 2];
            else
                dp[i] = dp[i - 1];
        }
        return dp[nums.length()];
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM70
* BM70 兑换零钱(一)

描述
```
给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。
如果无解，请返回-1.

数据范围：数组大小满足 0 \le n \le 100000≤n≤10000 ， 数组中每个数字都满足 0 < val \le 100000<val≤10000，0 \le aim \le 50000≤aim≤5000

要求：时间复杂度 O(n \times aim)O(n×aim) ，空间复杂度 O(aim)O(aim)。
```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM71
* BM71 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM72
* BM72 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM73
* BM73 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM74
* BM74 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM75
* BM75 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM76
* BM76 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM77
* BM77 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM78
* BM78 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM79
* BM79 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM80
* BM80 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM81
* BM81 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM82
* BM82 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


