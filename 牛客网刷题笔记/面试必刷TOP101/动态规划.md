# 动态规划

## 目录

- [BM62](#BM62)
- [BM63](#BM63)
- [BM64](#BM64)
- [BM65](#BM65)
- [BM66](#BM66)
- [BM67](#BM67)
- [BM68](#BM68)
- [BM69](#BM69)
- [BM70](#BM70)
- [BM71](#BM71)
- [BM72](#BM72)
- [BM73](#BM73)
- [BM74](#BM74)
- [BM75](#BM75)
- [BM76](#BM76)
- [BM77](#BM77)
- [BM78](#BM78)
- [BM79](#BM79)
- [BM80](#BM80)
- [BM81](#BM81)
- [BM82](#BM82)



## BM62
* BM62 斐波那契数列

描述
```
大家都知道斐波那契数列，现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。
斐波那契数列是一个满足 fib(x)=\left\{ \begin{array}{rcl} 1 & {x=1,2}\\ fib(x-1)+fib(x-2) &{x>2}\\ \end{array} \right.fib(x)={ 
1
fib(x−1)+fib(x−2)
​
  
x=1,2
x>2
​
  的数列
数据范围：1\leq n\leq 401≤n≤40
要求：空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n) ，本题也有时间复杂度 O(logn)O(logn) 的解法
```
<!-- ![img]() -->
```cpp
#方法一
class Solution {
public:
    int Fibonacci(int n) {
        if(n==1||n==2){
            return 1;
        }
        return Fibonacci(n-1)+Fibonacci(n-2);

    }
};
#方法二
class Solution {
public:
    int Fibonacci(int n) {
        //从0开始，第0项是0，第一项是1 fast-template
        if(n <= 1)
             return n;
         int res = 0;
         int a = 0;
         int b = 1;
        //因n=2时也为1，初始化的时候把a=0，b=1
         for (int i = 2; i <= n; i++){
         //第三项开始是前两项的和,然后保留最新的两项，更新数据相加
             res = (a + b);
             a = b;
             b = res;
         }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM63
* BM63 跳台阶

描述
```
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

数据范围：1 \leq n \leq 401≤n≤40
要求：时间复杂度：O(n)O(n) ，空间复杂度： O(1)O(1)
```
<!-- ![img]() -->
```cpp
#方法一
class Solution {
public:
    int jumpFloor(int number) {
        if(number==1){
            return 1;
        }
        if(number==2){
            return 2;
        }
        return jumpFloor(number-1)+jumpFloor(number-2);
        
    }
};
#方法二
class Solution {
public:
    int f[50]{0};
    int jumpFloor(int number) {
        if (number <= 1) return 1;
        if (f[number] > 0) return f[number];
        return f[number] = (jumpFloor(number-1)+jumpFloor(number-2));
    }
};
#方法三
class Solution {
public:
    int jumpFloor(int number) {
        int a = 1 , b = 1 , c = 1;
        for (int i = 2 ; i <= number ; i ++) {
            c = a+b , a = b , b = c;
        }
        return c;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM64
* BM64 最小花费爬楼梯

描述
```
给定一个整数数组 cost \cost  ，其中 cost[i]\cost[i]  是从楼梯第i \i 个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

数据范围：数组长度满足 1 \le n \le 10^5 \1≤n≤10 
5
   ，数组中的值满足 1 \le cost_i \le 10^4 \1≤cost 
i
​
 ≤10 
4
  
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        //dp[i]表示爬到第i阶楼梯需要的最小花费 fast-template
        vector<int> dp(cost.size() + 1, 0);
        for(int i = 2; i <= cost.size(); i++)
            //每次选取最小的方案
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        return dp[cost.size()];
   }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM65
* BM65 最长公共子序列(二)

描述
```
给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

数据范围：0 \le |str1|,|str2| \le 20000≤∣str1∣,∣str2∣≤2000
要求：空间复杂度 O(n^2)O(n 
2
 ) ，时间复杂度 O(n^2)O(n 
2
 )
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    string x = "";
    string y = "";
    //获取最长公共子序列 fast-template
    string ans(int i, int j, vector<vector<int>>& b){
        string res = "";
        //递归终止条件
        if(i == 0 || j == 0)
            return res;
        //根据方向，往前递归，然后添加本级字符
        if(b[i][j] == 1){
            res += ans(i - 1, j - 1, b);
            res += x[i - 1];
        }
        else if(b[i][j] == 2){
            res += ans(i - 1, j, b);
        }
        else if(b[i][j] == 3)
            res += ans(i,j - 1, b);
        return res;
    }
    string LCS(string s1, string s2) {
        //特殊情况
        if(s1.length() == 0 || s2.length() == 0)
            return "-1";
        int len1 = s1.length();
        int len2 = s2.length();
        x = s1;
        y = s2;
        //dp[i][j]表示第一个字符串到第i位，第二个字符串到第j位为止的最长公共子序列长度
        vector<vector<int>> dp(len1 + 1, vector<int>(len2 + 1, 0));
        //动态规划数组相加的方向
        vector<vector<int>> b(len1 + 1, vector<int>(len2 + 1, 0));
        //遍历两个字符串每个位置
        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){
                //遇到两个字符相等
                if(s1[i - 1] == s2[j - 1]){
                    //考虑由二者都向前一位
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    //来自于左上方
                    b[i][j] = 1;
                }
                //遇到的两个字符不同
                else{
                    //左边的选择更大，即第一个字符串后退一位
                    if(dp[i - 1][j] > dp[i][j - 1]){
                        dp[i][j] = dp[i - 1][j];
                        //来自于左方
                        b[i][j] = 2;
                    }
                    //右边的选择更大，即第二个字符串后退一位
                    else{
                        dp[i][j] = dp[i][j - 1];
                        //来自于上方
                        b[i][j] = 3;
                    }
                }
            }
        }
        //获取答案字符串
        string res = ans(len1, len2, b);
        //检查答案是否位空
        return  res != "" ? res : "-1";
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM66
* BM66 最长公共子串

描述
```
给定两个字符串str1和str2,输出两个字符串的最长公共子串
题目保证str1和str2的最长公共子串存在且唯一。 

数据范围： 1 \le |str1|,|str2| \le 50001≤∣str1∣,∣str2∣≤5000
要求： 空间复杂度 O(n^2)O(n 
2
 )，时间复杂度 O(n^2)O(n 
2
 )
```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM67
* BM67 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM68
* BM68 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM69
* BM69 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM70
* BM70 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM71
* BM71 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM72
* BM72 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM73
* BM73 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM74
* BM74 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM75
* BM75 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM76
* BM76 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM77
* BM77 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM78
* BM78 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM79
* BM79 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM80
* BM80 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM81
* BM81 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM82
* BM82 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


