# 二叉树
## 目录
- [BM23](#BM23)
- [BM24](#BM24)
- [BM25](#BM25)
- [BM26](#BM26)
- [BM27](#BM27)
- [BM28](#BM28)
- [BM29](#BM29)
- [BM30](#BM30)
- [BM31](#BM31)
- [BM32](#BM32)
- [BM33](#BM33)
- [BM34](#BM34)
- [BM35](#BM35)
- [BM36](#BM36)
- [BM37](#BM37)
- [BM38](#BM38)
- [BM39](#BM39)
- [BM40](#BM40)
- [BM41](#BM41)


## BM23
* BM23 二叉树的前序遍历

描述
```
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

数据范围：二叉树的节点数量满足 0 \le n \le 100 \0≤n≤100  ，二叉树节点的值满足 1 \le val \le 100 \1≤val≤100  ，树的各节点的值各不相同
示例 1：
```
![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636599059575/FE67E09E9BA5661A7AB9DF9638FB1FAC)
```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型vector
     */
    vector<int> preorderTraversal(TreeNode* root) {
        // write code here
        vector<int> res;
        preOrder(res, root);
        return res;
    }
    void preOrder(vector<int>& res,TreeNode* root){
        if(root==NULL){
            return;
        }
        res.push_back(root->val);
        preOrder(res, root->left);
        preOrder(res, root->right);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>



## BM24
* BM24 二叉树的中序遍历

描述
```
给定一个二叉树的根节点root，返回它的中序遍历结果。

数据范围：树上节点数满足 0 \le n \le 10000≤n≤1000，树上每个节点的值满足 0 \le val \le 10000≤val≤1000
进阶：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    void inorder(vector<int> &res, TreeNode* root){
        //遇到空节点则返回 fast-template
        if(root == NULL)
            return;
        //先遍历左子树
        inorder(res, root->left);
        //再遍历根节点
        res.push_back(root->val);
        //最后遍历右子树
        inorder(res, root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        //递归中序遍历
        inorder(res, root);
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM25
* BM25 二叉树的后序遍历

描述
```
给定一个二叉树，返回他的后序遍历的序列。

后序遍历是值按照 左节点->右节点->根节点 的顺序的遍历。

数据范围：二叉树的节点数量满足 0 \le n \le 100 \0≤n≤100  ，二叉树节点的值满足 1 \le val \le 100 \1≤val≤100  ，树的各节点的值各不相同

样例图
```
![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636596692486/64547759EAC75079FDBF501CAA589890)
```cpp
class Solution {
public:
    void postorder(vector<int> &res, TreeNode* root){
        //遇到空节点则返回 fast-template
        if(root == NULL)
            return;
        //先遍历左子树
        postorder(res, root->left);
        //再遍历右子树
        postorder(res, root->right);
         //最后遍历根节点
        res.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        //递归后序遍历
        postorder(res, root);
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM26
* BM26 求二叉树的层序遍历

描述
```
给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）
例如：
给定的二叉树是{3,9,20,#,#,15,7},
```
![img](https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76)
```cpp
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL)
            //如果是空，则直接返回空vector fast-template
            return res;
        //队列存储，进行层次遍历
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* cur;
        while(!q.empty()){
            //记录二叉树的某一行
            vector<int> row;
            int n = q.size();
            //因先进入的是根节点，故每层结点多少，队列大小就是多少
            for(int i = 0; i < n; i++){
                cur = q.front();
                q.pop();
                row.push_back(cur->val);
                //若是左右孩子存在，则存入左右孩子作为下一个层次
                if(cur->left)
                    q.push(cur->left);
                if(cur->right)
                    q.push(cur->right);
            }
            //每一层加入输出
            res.push_back(row);
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM27
* BM27 按之字形顺序打印二叉树

描述
```
给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）

数据范围：0 \le n \le 15000≤n≤1500,树上每个节点的val满足 |val| <= 1500∣val∣<=1500
要求：空间复杂度：O(n)O(n)，时间复杂度：O(n)O(n)
例如：
给定的二叉树是{1,2,3,#,#,4,5}
```
![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05)
```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL)
            //如果是空，则直接返回空vector fast-template
            return res;
        //队列存储，进行层次遍历
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* cur;
        bool need_reverse=true;
        while(!q.empty()){
            //记录二叉树的某一行
            vector<int> row;
            int n = q.size();
            need_reverse = !need_reverse;
            //因先进入的是根节点，故每层结点多少，队列大小就是多少
            for(int i = 0; i < n; i++){
                cur = q.front();
                q.pop();
                row.push_back(cur->val);
                //若是左右孩子存在，则存入左右孩子作为下一个层次
                if(cur->left)
                    q.push(cur->left);
                if(cur->right)
                    q.push(cur->right);
            }
            //每一层加入输出
            if(need_reverse){
                reverse(row.begin(), row.end());
            }
            res.push_back(row);
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM28
* BM28 二叉树的最大深度

描述
```
求给定二叉树的最大深度，
深度是指树的根节点到任一叶子节点路径上节点的数量。
最大深度是所有叶子节点的深度的最大值。
（注：叶子节点是指没有子节点的节点。）


数据范围：0 \le n \le 1000000≤n≤100000，树上每个节点的val满足 |val| \le 100∣val∣≤100
要求： 时间复杂度 O(n)O(n)
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //空结点没有深度 fast-template
        if(root == NULL)
            return 0;
        //返回子树深度+1
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM29
* BM29 二叉树中和为某一值的路径(一)

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


