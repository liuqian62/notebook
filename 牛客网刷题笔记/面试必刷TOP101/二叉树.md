# 二叉树
## 目录
- [BM23](#BM23)
- [BM24](#BM24)
- [BM25](#BM25)
- [BM26](#BM26)
- [BM27](#BM27)
- [BM28](#BM28)
- [BM29](#BM29)
- [BM30](#BM30)
- [BM31](#BM31)
- [BM32](#BM32)
- [BM33](#BM33)
- [BM34](#BM34)
- [BM35](#BM35)
- [BM36](#BM36)
- [BM37](#BM37)
- [BM38](#BM38)
- [BM39](#BM39)
- [BM40](#BM40)
- [BM41](#BM41)


## BM23
* BM23 二叉树的前序遍历

描述
```
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

数据范围：二叉树的节点数量满足 0 \le n \le 100 \0≤n≤100  ，二叉树节点的值满足 1 \le val \le 100 \1≤val≤100  ，树的各节点的值各不相同
示例 1：
```
![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636599059575/FE67E09E9BA5661A7AB9DF9638FB1FAC)
```cpp
/**
 * struct TreeNode {
 *	int val;
 *	struct TreeNode *left;
 *	struct TreeNode *right;
 *	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param root TreeNode类 
     * @return int整型vector
     */
    vector<int> preorderTraversal(TreeNode* root) {
        // write code here
        vector<int> res;
        preOrder(res, root);
        return res;
    }
    void preOrder(vector<int>& res,TreeNode* root){
        if(root==NULL){
            return;
        }
        res.push_back(root->val);
        preOrder(res, root->left);
        preOrder(res, root->right);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>



## BM24
* BM24 二叉树的中序遍历

描述
```
给定一个二叉树的根节点root，返回它的中序遍历结果。

数据范围：树上节点数满足 0 \le n \le 10000≤n≤1000，树上每个节点的值满足 0 \le val \le 10000≤val≤1000
进阶：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    void inorder(vector<int> &res, TreeNode* root){
        //遇到空节点则返回 fast-template
        if(root == NULL)
            return;
        //先遍历左子树
        inorder(res, root->left);
        //再遍历根节点
        res.push_back(root->val);
        //最后遍历右子树
        inorder(res, root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        //递归中序遍历
        inorder(res, root);
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM25
* BM25 二叉树的后序遍历

描述
```
给定一个二叉树，返回他的后序遍历的序列。

后序遍历是值按照 左节点->右节点->根节点 的顺序的遍历。

数据范围：二叉树的节点数量满足 0 \le n \le 100 \0≤n≤100  ，二叉树节点的值满足 1 \le val \le 100 \1≤val≤100  ，树的各节点的值各不相同

样例图
```
![img](https://uploadfiles.nowcoder.com/images/20211111/392807_1636596692486/64547759EAC75079FDBF501CAA589890)
```cpp
class Solution {
public:
    void postorder(vector<int> &res, TreeNode* root){
        //遇到空节点则返回 fast-template
        if(root == NULL)
            return;
        //先遍历左子树
        postorder(res, root->left);
        //再遍历右子树
        postorder(res, root->right);
         //最后遍历根节点
        res.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> res;
        //递归后序遍历
        postorder(res, root);
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM26
* BM26 求二叉树的层序遍历

描述
```
给定一个二叉树，返回该二叉树层序遍历的结果，（从左到右，一层一层地遍历）
例如：
给定的二叉树是{3,9,20,#,#,15,7},
```
![img](https://uploadfiles.nowcoder.com/images/20210114/999991351_1610616074120/036DC34FF19FB24652AFFEB00A119A76)
```cpp
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL)
            //如果是空，则直接返回空vector fast-template
            return res;
        //队列存储，进行层次遍历
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* cur;
        while(!q.empty()){
            //记录二叉树的某一行
            vector<int> row;
            int n = q.size();
            //因先进入的是根节点，故每层结点多少，队列大小就是多少
            for(int i = 0; i < n; i++){
                cur = q.front();
                q.pop();
                row.push_back(cur->val);
                //若是左右孩子存在，则存入左右孩子作为下一个层次
                if(cur->left)
                    q.push(cur->left);
                if(cur->right)
                    q.push(cur->right);
            }
            //每一层加入输出
            res.push_back(row);
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM27
* BM27 按之字形顺序打印二叉树

描述
```
给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）

数据范围：0 \le n \le 15000≤n≤1500,树上每个节点的val满足 |val| <= 1500∣val∣<=1500
要求：空间复杂度：O(n)O(n)，时间复杂度：O(n)O(n)
例如：
给定的二叉树是{1,2,3,#,#,4,5}
```
![img](https://uploadfiles.nowcoder.com/images/20210717/557336_1626492068888/41FDD435F0BA63A57E274747DE377E05)
```cpp
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    vector<vector<int> > Print(TreeNode* root) {
        vector<vector<int> > res;
        if(root == NULL)
            //如果是空，则直接返回空vector fast-template
            return res;
        //队列存储，进行层次遍历
        queue<TreeNode*> q;
        q.push(root);
        TreeNode* cur;
        bool need_reverse=true;
        while(!q.empty()){
            //记录二叉树的某一行
            vector<int> row;
            int n = q.size();
            need_reverse = !need_reverse;
            //因先进入的是根节点，故每层结点多少，队列大小就是多少
            for(int i = 0; i < n; i++){
                cur = q.front();
                q.pop();
                row.push_back(cur->val);
                //若是左右孩子存在，则存入左右孩子作为下一个层次
                if(cur->left)
                    q.push(cur->left);
                if(cur->right)
                    q.push(cur->right);
            }
            //每一层加入输出
            if(need_reverse){
                reverse(row.begin(), row.end());
            }
            res.push_back(row);
        }
        return res;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM28
* BM28 二叉树的最大深度

描述
```
求给定二叉树的最大深度，
深度是指树的根节点到任一叶子节点路径上节点的数量。
最大深度是所有叶子节点的深度的最大值。
（注：叶子节点是指没有子节点的节点。）


数据范围：0 \le n \le 1000000≤n≤100000，树上每个节点的val满足 |val| \le 100∣val∣≤100
要求： 时间复杂度 O(n)O(n)
```
<!-- ![img]() -->
```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //空结点没有深度 fast-template
        if(root == NULL)
            return 0;
        //返回子树深度+1
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM29
* BM29 二叉树中和为某一值的路径(一)

描述
```
给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。
1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点
2.叶子节点是指没有子节点的节点
3.路径只能从父节点到子节点，不能从子节点到父节点
4.总节点数目为n

例如：
给出如下的二叉树，\ sum=22 sum=22，
返回true，因为存在一条路径 5\to 4\to 11\to 25→4→11→2的节点值之和为 22

数据范围：
1.树上的节点数满足 0 \le n \le 100000≤n≤10000
2.每 个节点的值都满足 |val| \le 1000∣val∣≤1000
要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
进阶：空间复杂度 O(树的高度)O(树的高度)，时间复杂度 O(n)O(n)
```
![img](https://uploadfiles.nowcoder.com/images/20200807/999991351_1596786493913_8BFB3E9513755565DC67D86744BB6159)
```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        //空结点找不到路径 fast-template
        if(root == NULL)
            return false;
        //叶子结点，且路径和为sum
        if(root->left == NULL && root->right == NULL && sum - root->val == 0)
            return true;
        //递归进入子结点
        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM30
* BM30 二叉搜索树与双向链表

描述
```
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示
数据范围：输入二叉树的节点数 0 \le n \le 10000≤n≤1000，二叉树中每个节点的值 0\le val \le 10000≤val≤1000
要求：空间复杂度O(1)O(1)（即在原树上操作），时间复杂度 O(n)O(n)

注意:
1.要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继
2.返回链表中的第一个节点的指针
3.函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构
4.你不用输出双向链表，程序会根据你的返回值自动打印输出
```
![img](https://uploadfiles.nowcoder.com/images/20210605/557336_1622886924427/E1F1270919D292C9F48F51975FD07CE2)
```cpp
class Solution {
public:
    //返回的第一个指针，即为最小值，先定为null fast-template
    TreeNode* head = NULL;
    //中序遍历当前值的上一位，初值为最小值，先定为null
    TreeNode* pre = NULL;
    TreeNode* Convert(TreeNode* pRootOfTree) {
        if(pRootOfTree == NULL)
            //中序递归，叶子为空则返回
            return NULL;
        //首先递归到最左最小值
        Convert(pRootOfTree->left);
        //找到最小值，初始化head与pre
        if(pre == NULL){
            head = pRootOfTree;
            pre = pRootOfTree;
        }
        //当前结点与上一结点建立连接，将pre设置为当前值
        else{
            pre->right = pRootOfTree;
            pRootOfTree->left = pre;
            pre = pRootOfTree;
        }
        Convert(pRootOfTree->right);
        return head;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM31
* BM31 对称的二叉树

描述
```
给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）
例如：                                 下面这棵二叉树是对称的
```
![img](https://uploadfiles.nowcoder.com/images/20210926/382300087_1632642756706/A22A794C036C06431E632F9D5E2E298F)
```cpp
class Solution {
public:
    bool recursion(TreeNode* root1, TreeNode* root2){
        //可以两个都为空 fast-template
        if(root1 == NULL && root2 == NULL)
            return true;
        //只有一个为空或者节点值不同，必定不对称
        if(root1 == NULL || root2 == NULL || root1->val != root2->val)
            return false;
        //每层对应的节点进入递归
        return recursion(root1->left, root2->right) && recursion(root1->right, root2->left);
    }
    bool isSymmetrical(TreeNode* pRoot) {
        return recursion(pRoot, pRoot);
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## BM24
* BM24 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


