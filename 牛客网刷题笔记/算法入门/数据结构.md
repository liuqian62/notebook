# 数据结构

## 目录

- [栈](#栈)
  - [AB1](#AB1) 
  - [AB2](#AB2) 
  - [AB3](#AB3)
  - [AB4](#AB4)
  - [AB5](#AB5)
  - [AB6](#AB6)

- [队列](#队列)
  - [AB7](#AB7) 
  - [AB8](#AB8) 

- [链表](#链表)
  - [AB9](#AB9) 
  - [AB10](#AB10)
  - [AB11](#AB11)
  - [AB12](#AB12)



- [图论](#图论)
  - [AB13](#AB13) 
  - [AB14](#AB14) 
  - [AB15](#AB15) 


- [二叉树](#二叉树)
  - [AB16](#AB16) 
  - [AB17](#AB17) 

- [堆](#堆)
  - [AB18](#AB18) 


## 栈


### AB1
* AB1 【模板】栈

描述
```
请你实现一个栈。
操作：
push x：将 加x\x 入栈，保证 x\x 为 int 型整数。
pop：输出栈顶，并让栈顶出栈
top：输出栈顶，栈顶不出栈
输入描述：
第一行为一个正整数 n\n ，代表操作次数。(1 \leq n \leq 100000)(1≤n≤100000)
接下来的 n\n ，每行为一个字符串，代表一个操作。保证操作是题目描述中三种中的一种。


输出描述：
如果操作为push，则不输出任何东西。
如果为另外两种，若栈为空，则输出 "error“
否则按对应操作输出。
```
<!-- ![img]() -->
```cpp
#include<bits/stdc++.h>
using namespace std;

class Stack {
public:
    Stack(int size_){
        index = 0;
        size = size_;
        arr = new int[size];
    }
    void push(int x){
        if(index>= size){
            int *tmp = arr;
            size *=2;
            arr = new int[size];
            memcpy(arr, tmp, sizeof(int)*index);
            delete []tmp;
        }
        arr[index++]= x;
    }
    int pop(){
        if(index==0){
            cout<<"error"<<endl;
            return -1;
        }else{
            cout<<arr[--index]<<endl;
            return arr[index];
        }
    }
    void top(){
        if(index==0) cout<<"error"<<endl;
        else cout<<arr[index-1]<<endl;
    }
    
private:
    int index;
    int size;
    int *arr;
};

int main(int argc,char** argv){
    int n;
    cin>>n;
    Stack stk(n);
    string s;
    while(cin >> s){
        if(s=="push"){
            cin>>n;
            stk.push(n);
        }
        else if(s=="pop") stk.pop();
        else stk.top();
    }
    return 0;
}
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


### AB2

* AB2 栈的压入、弹出序列

描述
```
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。
1. 0<=pushV.length == popV.length <=1000
2. -1000<=pushV[i]<=1000
3. pushV 的所有数字均不相同
```
具体做法

    step 1：准备一个辅助栈，两个下标分别访问两个序列。
    step 2：辅助栈为空或者栈顶不等于出栈数组当前元素，就持续将入栈数组加入栈中。
    step 3：栈顶等于出栈数组当前元素就出栈。
    step 4：当入栈数组访问完，出栈数组无法依次弹出，就是不匹配的，否则两个序列都访问完就是匹配的。
    
![img](https://uploadfiles.nowcoder.com/images/20220421/397721558_1650532143383/7F25B229A4900F6E066BE03E92B0492E)

```cpp
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        int n = pushV.size();
        //辅助栈
        stack<int> s;
        //遍历入栈的下标
        int j = 0;
        //遍历出栈的数组
        for(int i = 0; i < n; i++){
            //入栈：栈为空或者栈顶不等于出栈数组
            while(j < n && (s.empty() || s.top() != popV[i])){
                s.push(pushV[j]);
                j++;
            }
            //栈顶等于出栈数组
            if(s.top() == popV[i])
                s.pop();
            //不匹配序列
            else
                return false;
        }
        return true;
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### AB3

* AB3 dosomething

描述
```
给出一个仅包含字符'(',')','{','}','['和']',的字符串，判断给出的字符串是否是合法的括号序列
括号必须以正确的顺序关闭，"()"和"()[]{}"都是合法的括号序列，但"(]"和"([)]"不合法。

数据范围：字符串长度 0\le n \le 100000≤n≤10000
要求：空间复杂度 O(n)O(n)，时间复杂度 O(n)O(n)
```

核心思想：

     每次遇到'(','{','['这三种字符的时候，将字符入栈stk；而每次遇到')','}',']'这三种字符的时候则让对应的匹配字符出栈。具体规则如下：
    1）引入辅助栈stk，遍历字符串，每次遇到'(','{','['字符的时候将字符入栈stk
    2）当遇到')','}',']'字符的时候，则检查栈是否空，且顶元素是否为匹配元素（如{和}匹配等），如果栈空或者栈顶元素不为匹配元素则括号序列不合法
    3）当栈非空，且栈顶元素为匹配元素，则栈顶元素出栈。
    4）循环匹配字符串，直到每次字符处理完
    5）检查栈stk是否为空，栈为空则序列合法，否则不合法（当括号以正确顺序关闭时则最后的栈为空）
    
![img](https://uploadfiles.nowcoder.com/images/20210718/9970047_1626609454058/6973900DD42B3AF6C4400356AE10B770)
```cpp
class Solution {
public:
    bool isValid(string s) {
         //辅助栈 fast-template
        stack<char> st;
         //遍历字符串
        for(int i = 0; i < s.length(); i++){
             //遇到左小括号
            if(s[i] == '(')
                //期待遇到右小括号
                st.push(')');
            //遇到左中括号
            else if(s[i] == '[')
                //期待遇到右中括号
                st.push(']');
            //遇到左打括号
            else if(s[i] == '{')
                //期待遇到右打括号
                st.push('}');
            //必须有左括号的情况下才能遇到右括号
            else if(st.empty())
                return false;
             //右括号匹配则弹出
            else if(st.top() == s[i])
                st.pop();
        }
        //栈中是否还有元素
        return st.empty();
    }
};
```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### AB4

* AB4 逆波兰表达式求值

描述
```
给定一个逆波兰表达式，求表达式的值。

数据范围：表达式长度满足 1≤n≤10^4
   ，表达式中仅包含数字和 + ，- , * , / ，其中数字的大小满足 |val| ≤200 。
```

解题思路

    逆波兰表达式求值的过程总是先列出运算符前面两个数字，然后将这两个数字进行相应运算，得到一个新的数字，这个数又与后面的数进行相应运算，直到结束。

    所以，可以先新建一个栈，当遇到数字时，直接压入栈中，遇到运算符时，先取出栈顶的两个数字，进行相应运算，再压回栈中。最后栈中剩下的那个元素即是表达式的值。
    
![img](https://uploadfiles.nowcoder.com/images/20220114/100241712_1642167889585/5D99B6A70EE4701B5D348BD506621531)


```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### AB1

* AB1 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>

### AB1

* AB1 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>




## 队列
### AB1

* AB1 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## 链表
### AB1
* AB1 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## 图论
### AB1
* AB1 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## 二叉树
### AB1
* AB1 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


## 堆
### AB1
* AB1 dosomething

描述
```

```
<!-- ![img]() -->
```cpp

```

<div align="right">
    <b><a href="#目录">↥ Back To Top</a></b>
</div>


