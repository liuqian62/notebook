# 面经八股文

# C++面试常问问题
## 语言特性
### 1. const相关
### 2. static相关
### 3. 构造函数
### 4. 深拷贝和浅拷贝
### 5. 空类的默认成员函数
### 6. 类型转换
### 7. 函数的模板和类模板
### 8. 其他
### 9. C++11新特性
## 多态相关的问题
### 1. 什么是多态
### 2. 重载、重写、隐藏的区别
### 3. 虚函数与纯虚函数
### 4. 基类为什么需要虚析构函数
### 5. 虚函数表

## 内存管理
### 1. C内存
### 2. C++内存分配
### 3. 类的内存占用
### 4. 指针与引用的区别
### 5. new的执行过程
### 6. new和malloc的区别
### 7. 悬空指针与野指针
### 8. 智能指针
### 9. 静态链接与动态链接
### 10. 加载程序的内存分布
### 11. malloc的底层实现
### 12. delete p与delete []的问题
### 13. delete this
### 避免内存泄漏
### 堆和栈的区别
### const变量的修改


## 数据结构
### 红黑树
### 哈希表

# 八股文总结
## C++基础
### 1.	手撕代码时常用的一些变换
* 自定义大堆小堆的排列：
  * 大堆：堆顶的元素最大，priority_queue<int, vector<int>, less<int>>
  * 小堆：堆顶的元素最小，priority_queue<int, vector<int>, greater<int>>
  * 默认是大堆，priority_queue<int> 
* 改变sort的排序为降序：sort(v.begin(), v.end(), greater<int>())
  * 改变sort的排序为降序：sort(v.begin(), v.end(), greater<int>())
* int、char、string之间的转换
  * int与char：int->char：num – ‘0’，          char->int：s + ‘0’
  * int与string：int->string：to_string(num)，   string->int：atoi(s.c_str())
### 2.	编译过程
编译分为四个过程：预编译、编译、汇编、链接
* `预编译`：处理以#开头的指令；
* `编译`：将源码.cpp翻译成汇编代码；
* `汇编`：将汇编代码翻译成机器指令；
* `链接`：一个源文件中函数可能引用了其他源文件的变量或函数，或者引用了库函数，链接的目的就是将这些文件链接成一个整体，从而生成一个可执行的.exe文件。
### 3.	静态链接、动态链接
* 静态链接
  * 在链接阶段，将源文件中用到的库函数与汇编生成的目标文件合并生成可执行文件；
  * `优点`：方便移植，执行速度快；
  * `缺点`：占内存，每次更新都要重新链接。
* 动态链接
  * 把调用的函数所在的文件模块和调用函数在文件中的位置等信息链接进目标程序，程序在运行时再从文件模块中寻找相应的代码；
  * `优点`：应用灵活，不占内存；
  * `缺点`：速度不如静态链接快。
### 4.	C++的内存分区
C++的内存分为：栈区、堆区、全局区/静态存储区、常量区、代码区
* `栈区`：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放；
* `堆区`：动态申请的内存空间，由程序员分配和释放，若程序结束后还没有释放，操作系统会自动回收；
* `全局区/静态存储区`：存放全局变量和静态变量，程序运行结束后系统自动回收；
* `常量区`：存放常量，不允许修改，系统自动回收；
* `代码区`：不允许修改，编译后的二进制文件存放在这里。
### 5.	内存对齐
* `什么是内存对齐`:
编译器将程序中的每个数据单元安排在字的整数倍的地址指向的内存之中；
* `内存对齐的原则`:
  * 结构体的首地址能够被其最宽基本类型成员大小与对齐基数中较小者所整除；
  * 结构体每个成员相对于结构体首地址的偏移量都是该成员大小与对齐基数中较小者的整数倍，如有需要，编译器会在成员之间加上填充字节；
  * 结构体的总大小为结构体最关基本类型成员大小与对齐基数中较小者的整数倍，如有需要，编译器会在最末尾一个成员之后加上填充字节。
* `为什么需要内存对齐`（主要是硬件设备方面的问题）:
  * 某些硬件设备只能存取对齐的数据，存取非对齐的数据会引发异常；
  * 相对于存取对齐数据，存取非对齐数据需要花费的时间分更多；
  * 某些硬件设备只支持简单指令存取对齐数据，不支持复杂指令存取非对齐数据；
* `内存对齐的优点`:
  * 提高内存的访问效率，因为CPU在读取内存时，是一块一块的读取；
  * 便于在不同平台之间进行移植，因为有的平台只支持对齐数据的存取。
### 6.	类大小的计算
`说明`：类大小的计算是指类实例化对象大小的计算，用sizeof对类名操作时，结果是该类型对象的大小。计算原则如下：
* 遵循结构体的对齐原则；
* 与普通成员变量有关，与成员函数和静态成员无关；
* 虚函数对类的大小有影响，因为虚函数表指针的影响；（需要一个虚函数指针指向虚函数表，多了一个指针的大小）
* 空类的大小为1，当用new来创建一个空类时，为了保证不同对象的地址不同，空类也占一个存储空间。
### 7.	C++中常用的关键字
* `Const`
  * 修饰普通变量变为常量；
  * 修饰函数参数，防止函数参数的值被改变；
  * 修饰成员变量，类内声明，初始化列表初始化（成员变量只在某个对象的生命周期内为常量，对整个类而言仍是变量）；
  * 修饰成员函数，只能访问成员变量，不能改变成员变量（除非有mutable修饰），不能调用非常量成员函数。
* `Static`
  * 修饰全局变量和全局函数，只在定义他们的源文件中可见，其他文件中不可见；
  * 修饰局部变量，作用域没变，仍为局部，生命周期变为了整个程序运行期间；
  * 修饰成员变量，所有类对象共享一份数据，编译阶段分配内存，类内定义类外初始化；
  * 修饰成员函数，所有类对象共享同一个函数，可以通过类名就行访问，静态成员函数只能访问静态成员变量。
* `Final`
  * 限制类不能被继承；
  * 限制虚函数不能被重写。
* `Inline`
  * 修饰函数为内联函数；
  * 成员函数默认为内联函数；
  * 内联函数在编译的时候将函数体的嵌入到每一个调用该函数的语句块中，以代码膨胀为代价，省去了函数调用的时间开销，但是内存占用多。
* `Mutable`
  * 如果需要在const成员函数中修改一个成员变量的值，则可以在变量声明中加入关键字mutable，如mutable int size_t。

### 8.	引用和指针的区别
* 指针本质是一个变量，需要分配内存，引用是一个对象的别名，不需要分配内存；
* 引用在定义时必须初始化，而指针可以不用初始化；
* 指针可以初始化为空，而引用不行，引用必须是一个已有对象的引用；
* 指针和引用的自增运算结果不同，指针是指向下一个地址，引用是引用的变量值加1；
* Sizeof结果不同，指针得到的是指针的大小，引用得到的引用变量的大小。
### 9.	空指针、悬空指针、野指针、void指针？
* `空指针`:用NULL或nullptr初始化，不指向任何对象；
* `悬空指针`:指针所指的内存被释放，而指针没有置空；
* `野指针`:未初始化的指针，指针所指的内存被释放后指针没有置为null；
* `void指针`:一种特殊类型的指针，可以存放任意对象的地址，任何类型的指针可以直接赋值给void指针，反之不行，void指针必须进行强制类型转换才能赋值给其他指针。

### 10.	内存泄漏
* `原因`:
  * 没有释放动态开辟的内存空间；
  * 没有匹配的调用new/delete、new[]/delete[]；
  * 多态时，没有将基类的析构函数定义为虚函数；
* `解决方法`:
  * 智能指针。
### 11.	智能指针
* `分类`:
* `实现原理`:
### 12.	new/delete的实现过程
* `new`:调用operator new()申请内存（底层一般用malloc实现），然后调用构造函数，初始化成员变量，最后返回类型指针；
* `delete`:调用析构函数，然后调用operator delete()释放内存（底层用free实现）。
### 13.	虚函数的实现原理
### 14.	构造函数不能定义为虚函数、析构函数一般定义为虚函数
### 15.	纯虚函数
### 16.	组合与继承
### 17.	重载、隐藏、重写
### 18.	指针函数、函数指针
### 19.	Struct和union的区别
### 20.	Include””与<>的区别
### 21.	左值和右值的区别
### 22.	Lambda表达式
### 23.	函数模板与类模板区别
### 24.	++i与i++

## 操作系统
### 1.	进程与线程的区别
### 2.	线程与协程
### 3.	进程的状态
### 4.	进程通信
### 5.	进程调度
### 6.	进程同步与互斥
### 7.	死锁
### 8.	用户态、内核态
### 9.	内存管理
### 10.	僵尸进程与孤儿进程
### 11.	线程池
### 12.	内存池


## 计算机网络
### 1.	五层模型结构
### 2.	TCP与UDP的区别
### 3.	TCP如何保证可靠传输
### 4.	流量控制与拥塞控制的区别
### 5.	TCP的拥塞控制方法
### 6.	TCP的三次握手
### 7.	什么是SYN泛洪攻击？如何避免？
### 8.	TCP的四次挥手
### 9.	TCP四次挥手中客户端和服务器的状态叫什么
### 10.	TCP 头部
### 11.	TCP的粘包、拆包问题
### 12.	DNS系统进行域名解析的过程
### 13.	浏览器输入网址后，发生的全过程
### 14.	什么是HTTP，它有什么特点
### 15.	 什么是HTTPS，它有什么特点
### 16.	HTTPS的加密（SSL）连接过程
### 17.	HTTP与HTTPS的区别，HTTPS的优缺点
### 18.	HTTP的两种请求方法get、post的区别
### 19.	HTTP1.0、HTTP1.1、HTTP2.0的区别
### 20.	HTTP状态码
### 21.	常用的三种IO复用模型select、poll、epoll
### 22.	Cookie技术

## 数据结构与算法
### 1.	常用排序算法的性能
### 2.	set/map、unordered_set/unordered_map区别
### 3.	红黑树
### 4.	B树、B+树
### 5.	跳表

## 数据库
### 1.	常用的SQL语句
### 2.	MySQL的基础架构
### 3.	事务
### 4.	MVCC机制
### 5.	锁机制
### 6.	MyISAM与InnoDB的区别
### 7.	MySQL索引
### 8.	数据库的三大范式

## Linux
### 1.	Git使用流程
* `创建仓库`:
  * git init：初始化仓库
  * git clone：克隆远程仓库
* `提交修改`:
  * git add：添加文件到仓库
  * git status：查看仓库当前状态
  * git commit：提交文件到本地仓库
* `提交远程仓库`:
  * git push
### 2.	查看磁盘
### 3.	查看进程对CPU、内存使用情况：top
### 4.	更改文件权限：chmod
### 5.	ls：查看文件夹中的文件情况
### 6.	pwd：查看当前工作目录路径
### 7.	rm：删除文件
### 8.	mv：	移动文件或修改文件名
### 9.	cp：复制文件
### 10.	cat：显示文件
### 11.	kill：杀死进程
### 12.	free：查看内存使用情况

## 设计模式
### 1.	设计模式的七大原则
### 2.	单例模式
### 3.	工厂模式
### 4.	观察者模式
## 场景题

